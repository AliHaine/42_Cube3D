Index: src/graphics/raycast/sprites.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\n#include \"../../../includes/includes.h\"\n\nstatic void\tinit_vars(t_sprite *sp, t_player *player, mlx_texture_t *img)\n{\n\tsp->fog = sp->dist / FOG_DISTANCE;\n\tif (sp->fog > 1)\n\t\treturn ;\n\tsp->vars.s_pos[2] = SCREEN_HEIGHT / 2.f;\n\tsp->vars.s_pos[0] = (sp->sp_xy[0] - player->player_coords_xy[0]);\n\tsp->vars.s_pos[1] = (sp->sp_xy[1] - player->player_coords_xy[1]);\n\tsp->vars.tmp[0] = sp->vars.s_pos[1] * -player->cos + sp->vars.s_pos[0] * player->sin;\n\tsp->vars.tmp[1] = sp->vars.s_pos[0] * player->cos + sp->vars.s_pos[1] * player->sin;\n\tsp->vars.s_pos[0] = sp->vars.tmp[0];\n\tsp->vars.s_pos[1] = sp->vars.tmp[1];\n\tsp->vars.s_pos[0] = (sp->vars.s_pos[0] * -1280 / sp->vars.s_pos[1]) + (SCREEN_WIDTH / 2.f);\n\tsp->vars.s_pos[1] = (sp->vars.s_pos[2] * 70 / sp->vars.s_pos[1]) + (SCREEN_HEIGHT / 2.f);\n\tsp->vars.size[0] = (int)((float)(img->width * sp->scale) / sp->vars.tmp[1]);\n\tsp->vars.size[1] = (int)((float)(img->height * sp->scale) / sp->vars.tmp[1]);\n\tif (sp->vars.size[0] < 0)\n\t\tsp->vars.size[0] = 0;\n\tif (sp->vars.size[1] < 0)\n\t\tsp->vars.size[1] = 0;\n\tsp->vars.t_pos[0] = (float)img->width;\n\tsp->vars.offset[0] = (float)img->width / (float)sp->vars.size[0];\n\tsp->vars.offset[1] = (float)img->height / (float)sp->vars.size[1];\n\tsp->vars.x = 0;\n}\n\nstatic void\tdraw_sp_pixel(t_sprite *sp, mlx_image_t *img_3d, mlx_texture_t *img, const float *dists)\n{\n\tuint32_t\tcolor;\n\tint\t\t\tvalue;\n\n\tcolor = 0;\n\tvalue = ((int)sp->vars.t_pos[1] * (int)img->width\n\t\t\t- (int)sp->vars.t_pos[0]) * 4;\n\tif (value > 0 && value < ((img->height * img->width) * 4) - 4)\n\t\tcolor = (img->pixels[value] << 24) | (img->pixels[value + 1]\n\t\t\t\t<< 16) | (img->pixels[value + 2] << 8) | img->pixels[value + 3];\n\tif (color != 0 && dists[sp->vars.sc_xy[0]] > sp->dist)\n\t{\n\t\tcolor = apply_fog(color, sp->fog);\n\t\tmlx_put_pixel(img_3d, sp->vars.sc_xy[0], sp->vars.sc_xy[1], color);\n\t}\n}\n\nstatic void\tdraw_sprite(t_sprite *sp, mlx_image_t *img_3d, mlx_texture_t *img, const float *dists)\n{\n\twhile (sp->vars.x++ < sp->vars.size[0])\n\t{\n\t\tsp->vars.sc_xy[0] = (int)(sp->vars.s_pos[0] - (float)sp->vars.x) + (sp->vars.size[0] / 2);\n\t\tif (sp->vars.sc_xy[0] >= SCREEN_WIDTH || sp->vars.sc_xy[0] < 0)\n\t\t{\n\t\t\tsp->vars.t_pos[0] -= sp->vars.offset[0];\n\t\t\tcontinue ;\n\t\t}\n\t\tsp->vars.t_pos[1] = (float)img->height;\n\t\tsp->vars.y = 0;\n\t\twhile (sp->vars.y++ < sp->vars.size[1] && ((int)sp->vars.t_pos[1] * img->width\n\t\t\t\t- (int)sp->vars.t_pos[0] >= 0))\n\t\t{\n\t\t\tsp->vars.sc_xy[1] = (int)(sp->vars.s_pos[1] - (float)sp->vars.y);\n\t\t\tif (sp->vars.sc_xy[1] >= 0 && sp->vars.sc_xy[1] < SCREEN_HEIGHT)\n\t\t\t{\n\t\t\t\tdraw_sp_pixel(sp, img_3d, img, dists);\n\t\t\t}\n\t\t\tsp->vars.t_pos[1] -= sp->vars.offset[1];\n\t\t}\n\t\tsp->vars.t_pos[0] -= sp->vars.offset[0];\n\t}\n}\n\nvoid\tenemy_attack_move(t_sprite *sp, t_player *player)\n{\n\tfloat\t\t\tstep;\n\tfloat\t\t\tangle;\n\tfloat\t\t\tdx;\n\tfloat\t\t\tdy;\n\n\tt_world *world = get_world_active();\n\n\tif (sp->dist < 50 || sp->dist > 1000)\n\t\treturn ;\n\tstep = 5.f;\n\tangle = atan2f(player->player_coords_xy[1]\n\t\t\t- sp->sp_xy[1], player->player_coords_xy[0] - sp->sp_xy[0]);\n\tdx = cosf(angle) * step;\n\tdy = sinf(angle) * step;\n\tif (get_world_char_at_pos((int)(sp->chunk_sp_xy[0] + dx) / 64, (int)sp->chunk_sp_xy[1] / 64) == '0')\n\t{\n\t\tsp->sp_xy[0] += dx;\n\t\tsp->chunk_sp_xy[0] += dx;\n\t}\n\tif (get_world_char_at_pos((int)sp->chunk_sp_xy[0] / 64, (int)(sp->chunk_sp_xy[1] + dy) / 64) == '0')\n\t{\n\t\tsp->sp_xy[1] += dy;\n\t\tsp->chunk_sp_xy[1] += dy;\n\t}\n\tif (is_chunk_change(&sp->cell_xy, world))\n\t{\n\t\treplace_on_world(&sp->chunk_sp_xy, get_chunk_from_pos(sp->chunk_sp_xy[0] / 64, sp->chunk_sp_xy[1] / 64));\n\t}\n\tsp->cell_xy[0] = (int)sp->chunk_sp_xy[0] / 64;\n\tsp->cell_xy[1] = (int)sp->chunk_sp_xy[1] / 64;\n}\n\nbool\tsprite_are_sorted(t_sprite **sprite)\n{\n\tint\ti;\n\tint\tj;\n\n\ti = -1;\n\twhile (sprite[++i])\n\t{\n\t\tj = i;\n\t\twhile (sprite[++j])\n\t\t{\n\t\t\tif (sprite[i]->dist < sprite[j]->dist)\n\t\t\t\treturn (false);\n\t\t}\n\t}\n\treturn (true);\n}\n\nvoid\tsort_sprites(t_player *player)\n{\n\tint\t\t\tij[2];\n\tt_sprite\t*tmp;\n\tfloat\t\tdxy[2];\n\tt_world *world = get_world_active();\n\n\tij[0] = -1;\n\twhile (world->sprites[++ij[0]])\n\t{\n\t\tdxy[0] = player->player_coords_xy[0] - world->sprites[ij[0]]->sp_xy[0];\n\t\tdxy[1] = player->player_coords_xy[1] - world->sprites[ij[0]]->sp_xy[1];\n\t\tworld->sprites[ij[0]]->dist = sqrtf(dxy[0] * dxy[0] + dxy[1] * dxy[1]);\n\t}\n\twhile (!sprite_are_sorted(world->sprites))\n\t{\n\t\tij[1] = -1;\n\t\twhile (++ij[1] < ij[0] - 1)\n\t\t{\n\t\t\tif (world->sprites[ij[1]]->dist < world->sprites[ij[1] + 1]->dist)\n\t\t\t{\n\t\t\t\ttmp = world->sprites[ij[1]];\n\t\t\t\tworld->sprites[ij[1]] = world->sprites[ij[1] + 1];\n\t\t\t\tworld->sprites[ij[1] + 1] = tmp;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid\tdraw_sprites(t_player *player, t_imgs *imgs, const float *dists)\n{\n\tt_world\t*world;\n\tint\t\ts;\n\n\ts = -1;\n\tworld = get_world_active();\n\tif (!world->sprites || !world->sprites[0])\n\t\treturn ;\n\tplayer->cos = cosf(player->playerangle);\n\tplayer->sin = sinf(player->playerangle);\n\tsort_sprites(player);\n\twhile (world->sprites[++s])\n\t{\n\t\tinit_vars(world->sprites[s], player, world->sprites[s]->texture);\n\t\tif (world->sprites[s]->fog > 1 || world->sprites[s]->dist < 15)\n\t\t\tcontinue ;\n\t\tdraw_sprite(world->sprites[s], imgs->img_3d, world->sprites[s]->texture, dists);\n\t\tif (world->sprites[s]->hostile)\n\t\t\tenemy_attack_move(world->sprites[s], player);\n\t}\n}\n
===================================================================
diff --git a/src/graphics/raycast/sprites.c b/src/graphics/raycast/sprites.c
--- a/src/graphics/raycast/sprites.c	
+++ b/src/graphics/raycast/sprites.c	
@@ -7,8 +7,8 @@
 	if (sp->fog > 1)
 		return ;
 	sp->vars.s_pos[2] = SCREEN_HEIGHT / 2.f;
-	sp->vars.s_pos[0] = (sp->sp_xy[0] - player->player_coords_xy[0]);
-	sp->vars.s_pos[1] = (sp->sp_xy[1] - player->player_coords_xy[1]);
+	sp->vars.s_pos[0] = (sp->sp_xy[0] - player->player_pos_xy[0]);
+	sp->vars.s_pos[1] = (sp->sp_xy[1] - player->player_pos_xy[1]);
 	sp->vars.tmp[0] = sp->vars.s_pos[1] * -player->cos + sp->vars.s_pos[0] * player->sin;
 	sp->vars.tmp[1] = sp->vars.s_pos[0] * player->cos + sp->vars.s_pos[1] * player->sin;
 	sp->vars.s_pos[0] = sp->vars.tmp[0];
@@ -123,30 +123,29 @@
 	return (true);
 }
 
-void	sort_sprites(t_player *player)
+void	sort_sprites(t_player *player, t_sprite ***sprites)
 {
 	int			ij[2];
 	t_sprite	*tmp;
 	float		dxy[2];
-	t_world *world = get_world_active();
 
 	ij[0] = -1;
-	while (world->sprites[++ij[0]])
+	while ((*sprites)[++ij[0]])
 	{
-		dxy[0] = player->player_coords_xy[0] - world->sprites[ij[0]]->sp_xy[0];
-		dxy[1] = player->player_coords_xy[1] - world->sprites[ij[0]]->sp_xy[1];
-		world->sprites[ij[0]]->dist = sqrtf(dxy[0] * dxy[0] + dxy[1] * dxy[1]);
+		dxy[0] = player->player_pos_xy[0] - (*sprites)[ij[0]]->sp_xy[0];
+		dxy[1] = player->player_pos_xy[1] - (*sprites)[ij[0]]->sp_xy[1];
+		(*sprites)[ij[0]]->dist = sqrtf(dxy[0] * dxy[0] + dxy[1] * dxy[1]);
 	}
-	while (!sprite_are_sorted(world->sprites))
+	while (!sprite_are_sorted((*sprites)))
 	{
 		ij[1] = -1;
 		while (++ij[1] < ij[0] - 1)
 		{
-			if (world->sprites[ij[1]]->dist < world->sprites[ij[1] + 1]->dist)
+			if ((*sprites)[ij[1]]->dist < (*sprites)[ij[1] + 1]->dist)
 			{
-				tmp = world->sprites[ij[1]];
-				world->sprites[ij[1]] = world->sprites[ij[1] + 1];
-				world->sprites[ij[1] + 1] = tmp;
+				tmp = (*sprites)[ij[1]];
+				(*sprites)[ij[1]] = (*sprites)[ij[1] + 1];
+				(*sprites)[ij[1] + 1] = tmp;
 			}
 		}
 	}
@@ -156,21 +155,26 @@
 {
 	t_world	*world;
 	int		s;
+	int		chunk;
 
-	s = -1;
+	chunk = -1;
 	world = get_world_active();
-	if (!world->sprites || !world->sprites[0])
-		return ;
 	player->cos = cosf(player->playerangle);
 	player->sin = sinf(player->playerangle);
-	sort_sprites(player);
-	while (world->sprites[++s])
+	while (++chunk < 9)
 	{
-		init_vars(world->sprites[s], player, world->sprites[s]->texture);
-		if (world->sprites[s]->fog > 1 || world->sprites[s]->dist < 15)
+		s = -1;
+		if (!world->sprites || !world->sprites[chunk] || !world->sprites[chunk][0])
 			continue ;
-		draw_sprite(world->sprites[s], imgs->img_3d, world->sprites[s]->texture, dists);
-		if (world->sprites[s]->hostile)
-			enemy_attack_move(world->sprites[s], player);
+		sort_sprites(player, &world->sprites[chunk]);
+		while (world->sprites[chunk][++s])
+		{
+			init_vars(world->sprites[chunk][s], player, world->sprites[chunk][s]->texture);
+			if (world->sprites[chunk][s]->fog > 1 || world->sprites[chunk][s]->dist < 15)
+				continue ;
+			draw_sprite(world->sprites[chunk][s], imgs->img_3d, world->sprites[chunk][s]->texture, dists);
+			if (world->sprites[chunk][s]->hostile)
+				enemy_attack_move(world->sprites[chunk][s], player);
+		}
 	}
 }
