Index: src/world/world_dynamic_generator.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   world_dynamic_generator.c                          :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: ayagmur <marvin@42.fr>                     +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2023/08/27 14:40:18 by ayagmur           #+#    #+#             */\n/*   Updated: 2023/08/27 14:40:20 by ayagmur          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../../includes/concepts/world.h\"\n\nstatic void\tworld_place_map(t_world *world, int chunk_num)\n{\n\tint\ti;\n\tint\tincrementation;\n\tint\tchunk;\n\tint\tmul;\n\n\ti = -1;\n\tmul = 1;\n\tchunk = 0;\n\tif (chunk_num == 1)\n\t{\n\t\tchunk = 6;\n\t\tincrementation = -3;\n\t}\n\telse if (chunk_num == 7)\n\t\tincrementation = 3;\n\telse if (chunk_num == 3)\n\t{\n\t\tmul = 3;\n\t\tchunk = 2;\n\t\tincrementation = -1;\n\t}\n\telse\n\t{\n\t\tmul = 3;\n\t\tincrementation = 1;\n\t}\n\twhile (i++ < 2)\n\t\tcopy_tab(world->world[(chunk + i * mul) + incrementation], world->world[chunk + i * mul], world->height, world->width);\n\ti = -1;\n\tchunk += incrementation;\n\twhile (i++ < 2)\n\t\tcopy_tab(world->world[(chunk + i * mul) + incrementation], world->world[chunk + i * mul], world->height, world->width);\n}\n\nstatic void\tside_generator(t_world *world, int chunk_num)\n{\n\tint\ti;\n\tint\tchunk;\n\tint\tincrementation;\n\n\ti = -1;\n\tchunk = 0;\n\tif (chunk_num == 3 || chunk_num == 5)\n\t{\n\t\tincrementation = 3;\n\t\tif (chunk_num == 5)\n\t\t\tchunk = 2;\n\t}\n\telse\n\t{\n\t\tincrementation = 1;\n\t\tif (chunk_num == 7)\n\t\t\tchunk = 6;\n\t}\n\twhile (i++ < 2)\n\t\tchunk_generator(world, chunk + (incrementation * i));\n}\n\nstatic int\tget_chunk_from_corner(int iterator, int chunk_num)\n{\n\tif (iterator == 1)\n\t{\n\t\tif (chunk_num == 0 || chunk_num == 2)\n\t\t\treturn (1);\n\t\telse\n\t\t\treturn (7);\n\t}\n\telse\n\t{\n\t\tif (chunk_num == 0 || chunk_num == 6)\n\t\t\treturn (3);\n\t\telse if (chunk_num == 2 || chunk_num == 8)\n\t\t\treturn (5);\n\t}\n\treturn (chunk_num);\n}\n\nbool\tworld_dynamic_generator(t_player *player)\n{\n\tint\t\tstart_chunk;\n\tint\t\tchunk;\n\tt_world\t*world;\n\tint\t\titerator;\n\n\tworld = get_world_active();\n\tstart_chunk = get_chunk_from_pos(player->player_cell_xy[0], player->player_cell_xy[1]);\n\titerator = 1;\n\tif (is_chunk_on_corner(start_chunk))\n\t\titerator = 2;\n\twhile (iterator-- > 0)\n\t{\n\t\tchunk = get_chunk_from_corner(iterator, start_chunk);\n\t\tworld_place_map(world, chunk);\n\t\tside_generator(world, chunk);\n\t\treplace_on_world(&player->player_pos_xy, chunk);\n\t}\n\treturn (0);\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/world/world_dynamic_generator.c b/src/world/world_dynamic_generator.c
--- a/src/world/world_dynamic_generator.c	
+++ b/src/world/world_dynamic_generator.c	
@@ -109,6 +109,7 @@
 		world_place_map(world, chunk);
 		side_generator(world, chunk);
 		replace_on_world(&player->player_pos_xy, chunk);
+		sprites_place(world, chunk);
 	}
 	return (0);
 }
Index: src/world/chunk_utils.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   chunk_utils.c                                      :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: ayagmur <marvin@42.fr>                     +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2023/08/22 22:23:37 by ayagmur           #+#    #+#             */\n/*   Updated: 2023/08/22 22:23:39 by ayagmur          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../../includes/includes.h\"\n\n/* Give a position (in cell), return the chunk that matches the position */\n\nint\tget_chunk_from_pos(int x, int y)\n{\n\tint\t\tcell;\n\tint\t\tline;\n\tt_world\t*world;\n\n\tcell = -1;\n\tline = -1;\n\tworld = get_world_active();\n\tif (y > (world->height * 3) || x > (world->width * 3))\n\t\treturn (-1);\n\twhile (line++ < 2)\n\t{\n\t\tif (y < (world->height * (line + 1)))\n\t\t{\n\t\t\twhile (cell++ < 2)\n\t\t\t\tif (x < (world->width * (cell + 1)))\n\t\t\t\t\treturn (cell + (line * 3));\n\t\t}\n\t}\n\treturn (0);\n}\n\nbool\tis_chunk_change(int cells[][2], t_world *world)\n{\n\tif (cells[0][0] >= (world->width) && cells[0][0] <= ((world->width * 2) - 1)\n\t\t&& cells[0][1] >= (world->height)\n\t\t&& cells[0][1] <= ((world->height * 2) - 1))\n\t\treturn (false);\n\treturn (true);\n}\n\nvoid\tchunk_generator(t_world *world, int chunk)\n{\n\tint\t\ty;\n\tint\t\tx;\n\tt_biome\t*biome;\n\n\ty = -1;\n\tx = -1;\n\tbiome = get_random_biome(world->biome);\n\twhile (y++ < world->height)\n\t{\n\t\twhile (x++ < world->width)\n\t\t{\n\t\t\tworld->world[chunk][y][x] = '0';\n\t\t\tif (!get_rand_num(4, 1))\n\t\t\t{\n\t\t\t\tif (!get_rand_num(10000, 1))\n\t\t\t\t\tworld->world[chunk][y][x] = '(';\n\t\t\t\telse if (biome != NULL)\n\t\t\t\t\tworld->world[chunk][y][x] = get_random_block_from_biome(biome).block_char;\n\t\t\t\telse\n\t\t\t\t\tworld->world[chunk][y][x] = '1';\n\t\t\t}\n\t\t}\n\t\tx = -1;\n\t}\n}\n\nbool\tis_chunk_on_corner(int chunk_num)\n{\n\tif (chunk_num == 0 || chunk_num == 2\n\t\t|| chunk_num == 6 || chunk_num == 8)\n\t\treturn (true);\n\treturn (false);\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/world/chunk_utils.c b/src/world/chunk_utils.c
--- a/src/world/chunk_utils.c	
+++ b/src/world/chunk_utils.c	
@@ -60,7 +60,7 @@
 		while (x++ < world->width)
 		{
 			world->world[chunk][y][x] = '0';
-			if (!get_rand_num(4, 1))
+			if (!get_rand_num(10, 1))
 			{
 				if (!get_rand_num(10000, 1))
 					world->world[chunk][y][x] = '(';
Index: .d/default.cub
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>EA assets/walls/blackstone.png\nSO assets/walls/budding_amethyst.png\nWE assets/walls/carved_pumpkin.png\nNO assets/walls/carved_pumpkin.png\n\nC      0,191,255\nF      32,139,34\n\n                     1111111\n11111111111111111111110000>1\n1>000>00<0010^>0v0^10>010001\n10v00^01^0<000>0^00010<10>0(\n10E^000^v00100^0v00>0^0v1111111\n10^<00<000^00^000^00^0<*0^01111\n10111111100^v0^0<00^0>001011111\n10000>0110000000111111110001\n1111000010>000>00000Z11000001\n1000011110000>0011111100000001\n1111000011111111111110000000001\n1000000011111111111111111111111\n100000001             1$1\n 100000001            101\n  100000001           101\n   100000001          101\n    100000001         101\n     100000001        101\n      100000001       101\n       100000001      101\n        100000001     101\n         100000001111110111111\n          10000000100000001001\n           1000000010100000001\n            100000001000000001\n             10000000100001001\n              1000000010100001\n               100000001000001\n                1000000010111\n                 1000000001\n                  100000001\n                  111111111\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.d/default.cub b/.d/default.cub
--- a/.d/default.cub	
+++ b/.d/default.cub	
@@ -7,15 +7,15 @@
 F      32,139,34
 
                      1111111
-11111111111111111111110000>1
-1>000>00<0010^>0v0^10>010001
-10v00^01^0<000>0^00010<10>0(
-10E^000^v00100^0v00>0^0v1111111
-10^<00<000^00^000^00^0<*0^01111
-10111111100^v0^0<00^0>001011111
-10000>0110000000111111110001
-1111000010>000>00000Z11000001
-1000011110000>0011111100000001
+1111111111111111111111000001
+0000000000010000000100010001
+100000010000000000001001000(
+10E0000000010000000000001111111
+10000000000000000000000*0001111
+1011111110000000000000001011111
+1000000110000000111111110001
+11110000100000000000Z11000001
+100001111000000011111100000001
 1111000011111111111110000000001
 1000000011111111111111111111111
 100000001             1$1
Index: includes/concepts/sprites.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\n#ifndef SPRITES_H\n# define SPRITES_H\n\n# include \"../includes.h\"\n\ntypedef enum {\n\tEMMA,\n\tMUSHROOM,\n\tRED_FLOWER,\n\tPINK_FLOWER,\n\tWEEDS,\n\tTOTAL_LENGTH,\n}\tSprite;\n\nstatic const char\t\t*g_sprites_name[] = {\n\t\"e_0\",\n\t\"brown_mushroom\",\n\t\"poppy\",\n\t\"pink_tulip\",\n\t\"carrots_stage1\",\n};\n\ntypedef struct s_sprite_calc\n{\n\tint\t\t\t\tx;\n\tint\t\t\t\ty;\n\tint\t\t\t\tsize[2];\n\tfloat\t\t\tt_pos[2];\n\tfloat\t\t\toffset[2];\n\tfloat\t\t\ts_pos[3];\n\tfloat\t\t\ttmp[2];\n\tint\t\t\t\tsc_xy[2];\n}\t\t\t\t\tt_sprite_calc;\n\ntypedef struct s_sprite\n{\n\tchar\t\t\tc;\n\tbool\t\t\thostile;\n\tint\t\t\t\tscale;\n\tfloat\t\t\tdist;\n\tfloat\t\t\tsp_xy[2];\n\tfloat\t\t\tchunk_sp_xy[2];\n\tint\t\t\t\tchunk_save;\n\tint\t\t\t\tcell_xy[2];\n\tfloat\t\t\tfog;\n\tmlx_texture_t\t*texture;\n\tt_sprite_calc\tvars;\n}\t\t\t\t\tt_sprite;\n\nvoid\t\tdraw_sprites(t_player *player, t_imgs *imgs, const float *dists);\n\nvoid\t\tadd_sprite(t_world *world, char c, int y, int x);\nvoid\t\tdelete_sprite(t_sprite **sprites, int s);\nvoid\t\tfree_all_sprites(t_sprite ***sprites);\nt_sprite\t*get_sprite_by_int(t_sprite **sprites, int x, int y);\n\n#endif
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/includes/concepts/sprites.h b/includes/concepts/sprites.h
--- a/includes/concepts/sprites.h	
+++ b/includes/concepts/sprites.h	
@@ -10,7 +10,11 @@
 	RED_FLOWER,
 	PINK_FLOWER,
 	WEEDS,
-	TOTAL_LENGTH,
+	CRIMSON_FUNGUS,
+	FIRE_CORAL,
+	WARPD_FUNFUS,
+	WITHER_ROSE,
+	SPRITES_NUMBER,
 }	Sprite;
 
 static const char		*g_sprites_name[] = {
@@ -19,6 +23,10 @@
 	"poppy",
 	"pink_tulip",
 	"carrots_stage1",
+	"crimson_fungus",
+	"fire_coral",
+	"warped_fungus",
+	"wither_rose"
 };
 
 typedef struct s_sprite_calc
@@ -39,6 +47,8 @@
 	bool			hostile;
 	int				scale;
 	float			dist;
+	int				x_origin;
+	int				y_origin;
 	float			sp_xy[2];
 	float			chunk_sp_xy[2];
 	int				chunk_save;
@@ -50,9 +60,13 @@
 
 void		draw_sprites(t_player *player, t_imgs *imgs, const float *dists);
 
-void		add_sprite(t_world *world, char c, int y, int x);
+void		sprites_place(t_world *world, int chunk);
+void		reload_sprite_pos(t_world *world);
+void		add_sprite(t_world *world, int chunk, char c, int y, int x);
 void		delete_sprite(t_sprite **sprites, int s);
-void		free_all_sprites(t_sprite ***sprites);
+void		free_all_sprites(t_world *world);
 t_sprite	*get_sprite_by_int(t_sprite **sprites, int x, int y);
 
+char		get_rand_sprite_char(t_world *world);
+
 #endif
\ No newline at end of file
Index: src/parsing/map_parse.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   map_parse.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: ayagmur <marvin@42.fr>                     +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2023/09/03 19:06:36 by ayagmur           #+#    #+#             */\n/*   Updated: 2023/09/03 19:06:37 by ayagmur          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../../includes/includes.h\"\n\n//todo\nstatic bool\tfill_map_tab(char *line, t_player *player, t_world *world, int iterator)\n{\n\tint\ti;\n\n\ti = 0;\n\twhile (line[i] && line[i] != '\\n')\n\t{\n\t\tif (!is_allowed_char(line[i]))\n\t\t\treturn (false);\n\t\telse if (is_sprite_char(line[i]))\n\t\t\tadd_sprite(world, line[i], iterator, i);\n\t\telse if (is_player_char(line[i]))\n\t\t{\n\t\t\tplayer->have_player = true;\n\t\t\tset_player(i, iterator, player, 0);\n\t\t\tworld->world[4][iterator][i] = '0';\n\t\t}\n\t\telse if (line[i] == ' ')\n\t\t\tworld->world[4][iterator][i] = '0';\n\t\telse\n\t\t\tworld->world[4][iterator][i] = line[i];\n\t\ti++;\n\t}\n\twhile (i < world->width)\n\t\tworld->world[4][iterator][i++] = '0';\n\tworld->world[4][iterator][i] = '\\0';\n\treturn (true);\n}\n\nbool\tparse_main(t_file *file, t_player *player, t_world *world)\n{\n\tint\titerator;\n\n\titerator = 0;\n\twhile (iterator < world->height)\n\t{\n\t\tif (!fill_map_tab(file->line, player, world, iterator))\n\t\t{\n\t\t\tmsg_write(2, 2, ERROR_MAP_CHAR);\n\t\t\treturn (false);\n\t\t}\n\t\titerator++;\n\t\tget_next_line(file);\n\t}\n\tif (!player->have_player)\n\t\tmsg_write(2, 2, ERROR_PLAYER);\n\treturn (true);\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/parsing/map_parse.c b/src/parsing/map_parse.c
--- a/src/parsing/map_parse.c	
+++ b/src/parsing/map_parse.c	
@@ -23,7 +23,7 @@
 		if (!is_allowed_char(line[i]))
 			return (false);
 		else if (is_sprite_char(line[i]))
-			add_sprite(world, line[i], iterator, i);
+			add_sprite(world, 4, line[i], iterator, i);
 		else if (is_player_char(line[i]))
 		{
 			player->have_player = true;
@@ -58,6 +58,8 @@
 		get_next_line(file);
 	}
 	if (!player->have_player)
+	{
 		msg_write(2, 2, ERROR_PLAYER);
+	}
 	return (true);
 }
Index: includes/concepts/world.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   world.h                                            :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: ayagmur <marvin@42.fr>                     +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2023/08/22 20:40:50 by ayagmur           #+#    #+#             */\n/*   Updated: 2023/08/22 20:40:53 by ayagmur          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#ifndef WORLD_H\n# define WORLD_H\n\n# include \"../includes.h\"\n# include \"biome.h\"\n\ntypedef struct s_sounds\tt_sounds;\n\ntypedef enum {\n\tWORLD_DEFAULT,\n\tWORLD_NETHER,\n\tWORLD_END,\n\tWORLD_BACKROOM,\n\tWORLD_NUMBER,\n}\tWorld;\n\ntypedef struct s_world\n{\n\tWorld\t\t\tworld_name;\n\tchar\t\t\t***world;\n\tt_biome\t\t\t**biome;\n\tt_sounds\t\t*ambiant_sound;\n\tt_sprite\t\t**sprites;\n\tint\t\t\t\theight;\n\tint\t\t\t\twidth;\n\tuint32_t\t\tbt_color[2];\n\tmlx_image_t\t\t*ceil;\n\tmlx_image_t\t\t*floor;\n\tDifficulty\t\tdifficulty;\n\tbool\t\t\tskybox;\n\tbool\t\t\tis_active;\n}\tt_world;\n\n//loader\nvoid\t\tworld_loader(t_core *core);\nbool\t\tworld_creator(World world, t_biome **biomes, t_sounds *ambient_sound, int height, int width, const uint32_t bt_color[2], mlx_image_t *ceil, mlx_image_t *floor, Difficulty difficulty, bool is_active, bool skybox);\nvoid\t\tchunk_generator(t_world *world, int chunk);\n\n//accessor\nt_world\t\t*get_world(int num);\nt_world\t\t*get_world_active(void);\nchar\t\tget_world_char_at_pos(int x, int y);\nvoid\t\tset_world(t_world world, int num);\nvoid\t\tfree_world(void);\n\n//utils\nbool\t\tis_chunk_change(int cells[][2], t_world *world);\nint\t\t\tget_chunk_from_pos(int x, int y);\nbool\t\tis_chunk_on_corner(int chunk_num);\nbool\t\tworld_dynamic_generator(t_player *player);\nvoid\t\tchange_active_world(t_world\t*new_world);\nvoid\t\treplace_on_world(float coords[][2], int num);\n\n//biome\nvoid\t\tbiome_loader(void);\n\n#endif\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/includes/concepts/world.h b/includes/concepts/world.h
--- a/includes/concepts/world.h	
+++ b/includes/concepts/world.h	
@@ -32,7 +32,7 @@
 	char			***world;
 	t_biome			**biome;
 	t_sounds		*ambiant_sound;
-	t_sprite		**sprites;
+	t_sprite		***sprites;
 	int				height;
 	int				width;
 	uint32_t		bt_color[2];
Index: src/world/world_accessor.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   world_accessor.c                                   :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: ayagmur <marvin@42.fr>                     +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2023/08/22 22:23:49 by ayagmur           #+#    #+#             */\n/*   Updated: 2023/08/22 22:23:50 by ayagmur          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../../includes/concepts/world.h\"\n\nstatic t_world\t\t\tg_worlds[WORLD_NUMBER];\n\nt_world\t*get_world(int num)\n{\n\treturn (&g_worlds[num]);\n}\n\nt_world\t*get_world_active(void)\n{\n\tint\ti;\n\n\ti = WORLD_NUMBER;\n\twhile (i-- > 0)\n\t\tif (get_world(i)->is_active)\n\t\t\treturn (get_world(i));\n\treturn (0);\n}\n\nchar get_world_char_at_pos(int x, int y)\n{\n\tt_world\t*world;\n\n\tworld = get_world_active();\n\treturn (world->world[get_chunk_from_pos(x, y)][y % world->height][x % world->width]);\n}\n\nvoid\tset_world(t_world world, int num)\n{\n\tg_worlds[num] = world;\n}\n\nvoid\tfree_world(void)\n{\n\tint\t\ti;\n\tt_world\t*world;\n\n\ti = WORLD_NUMBER;\n\twhile (i-- > 0)\n\t{\n\t\tworld = get_world(i);\n\t\tfree_all_sprites(&world->sprites);\n\t\tfree_tab_three(world->world);\n\t\tfree(world->biome);\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/world/world_accessor.c b/src/world/world_accessor.c
--- a/src/world/world_accessor.c	
+++ b/src/world/world_accessor.c	
@@ -52,7 +52,7 @@
 	while (i-- > 0)
 	{
 		world = get_world(i);
-		free_all_sprites(&world->sprites);
+//		free_all_sprites(world);
 		free_tab_three(world->world);
 		free(world->biome);
 	}
Index: src/world/world_loader.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   world_loader.c                                     :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: ayagmur <marvin@42.fr>                     +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2023/08/02 12:35:56 by ayagmur           #+#    #+#             */\n/*   Updated: 2023/08/02 12:35:57 by ayagmur          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../../includes/includes.h\"\n\nstatic bool\tworld_malloc(int height, int width, char ***map)\n{\n\tint\ti;\n\n\ti = 0;\n\t(*map) = malloc(sizeof(char *) * (height + 1));\n\tif (!*map)\n\t\treturn (false);\n\t(*map)[height] = 0;\n\twhile (i < height)\n\t{\n\t\t(*map)[i] = malloc(sizeof(char) * width + 1);\n\t\tif (!(*map)[i])\n\t\t\treturn (false);\n\t\t(*map)[i][width] = 0;\n\t\ti++;\n\t}\n\treturn (true);\n}\n\nstatic void\tworld_generator(t_world *world)\n{\n\tint\ti;\n\n\ti = -1;\n\twhile (i++ < 8)\n\t\tchunk_generator(world, i);\n}\n\nstatic t_biome\t**world_get_biomes(int biome_number, ...)\n{\n\tt_biome\t**biomes;\n\tva_list\tva_biomes;\n\n\tva_start(va_biomes, biome_number);\n\tbiomes = malloc(sizeof(t_biome *) * (biome_number + 1));\n\tbiomes[biome_number] = 0;\n\twhile (biome_number-- > 0)\n\t\tbiomes[biome_number] = va_arg(va_biomes, t_biome *);\n\tva_end(va_biomes);\n\treturn (biomes);\n}\n\n/* Create new World with specified properties\n * Before call this function, add the name of your\n * World in the Enum World\n *\n * @param world_name\tThe Enum value of your world\n * @param biomes\t\tThe biomes compositions of your world (optional)\n * @param ambient_sound\tThe ambient_sound of your world (optional)\n * @param height\t\tThe height of your world. Do not set too high value\n * @param width\t\t\tThe width of your world. Do not set too high value\n * @param bt_color\t\tThe color of ceil and floor if there is no image are define for them (optional)\n * @param ceil\t\t\tThe ceil image\n * @param floor\t\t\tThe floor image\n * @param difficulty\tThe difficulty of the world;\n * @param is_active\t\tBy default you have to set this boolean to false\n * @param skybox\t\tSet the mode of ceil (skybox or default)\n * */\n\nbool\tworld_creator(World world_name, t_biome **biomes, t_sounds *ambient_sound, int height, int width, const uint32_t bt_color[2], mlx_image_t *ceil, mlx_image_t *floor, Difficulty difficulty, bool is_active, bool skybox)\n{\n\tint\t\ti;\n\tt_world\tworld;\n\n\ti = 0;\n\tworld_name = world_name;\n\tworld.biome = biomes;\n\tworld.ambiant_sound = ambient_sound;\n\tworld.height = height;\n\tworld.width = width;\n\tworld.bt_color[0] = bt_color[0];\n\tworld.bt_color[1] = bt_color[1];\n\tworld.ceil = ceil;\n\tworld.floor = floor;\n\tworld.difficulty = difficulty;\n\tworld.world = malloc(sizeof(char **) * 9);\n\tworld.is_active = is_active;\n\tworld.skybox = skybox;\n\tworld.sprites = NULL;\n\twhile (i < 9)\n\t\tworld_malloc(height * 3, width * 3, &world.world[i++]);\n\tworld_generator(&world);\n\tset_world(world, world_name);\n\treturn (true);\n}\n\nvoid\tworld_loader(t_core *core)\n{\n\tbiome_loader();\n\tworld_creator(WORLD_NETHER, world_get_biomes(3, get_biome(BIOME_DARK), get_biome(BIOME_DRAGON), get_biome(BIOME_RED)), get_sound(NETHER_AMBIANT_SOUND), 32, 32, (uint32_t []){0, 0}, core->imgs.skybox_nether, get_block_image(NETHERRACK), HARD, false, true);\n\tworld_creator(WORLD_END, world_get_biomes(2, get_biome(BIOME_END), get_biome(BIOME_CHORUS)), get_sound(END_AMBIANT_SOUND), 32, 32, (uint32_t []){0, 0}, core->imgs.skybox_end, get_block_image(BLOCK_END_STONE), NORMAL, false, true);\n\tworld_creator(WORLD_BACKROOM, world_get_biomes(1, get_biome(BIOME_BACKROOM)), get_sound(BACKROOM_AMBIANT_SOUND), 32, 32, (uint32_t []){0, 0}, core->imgs.backrooms_ceil, get_block_image(BACKROOM_FLOOR), HARD, false, false);\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/world/world_loader.c b/src/world/world_loader.c
--- a/src/world/world_loader.c	
+++ b/src/world/world_loader.c	
@@ -12,6 +12,26 @@
 
 #include "../../includes/includes.h"
 
+void sprites_generator(t_world *world)
+{
+	int chunk;
+	int xy[2];
+
+	chunk = -1;
+	while (++chunk < 9)
+	{
+		xy[1] = -1;
+		while (++xy[1] < world->height)
+		{
+			xy[0] = -1;
+			while (++xy[0] < world->width)
+				if (!get_rand_num(5, 1))
+					add_sprite(world, chunk, get_rand_sprite_char(world), xy[1], xy[0]);
+		}
+	}
+	reload_sprite_pos(world);
+}
+
 static bool	world_malloc(int height, int width, char ***map)
 {
 	int	i;
@@ -78,7 +98,7 @@
 	t_world	world;
 
 	i = 0;
-	world_name = world_name;
+	world.world_name = world_name;
 	world.biome = biomes;
 	world.ambiant_sound = ambient_sound;
 	world.height = height;
@@ -91,10 +111,14 @@
 	world.world = malloc(sizeof(char **) * 9);
 	world.is_active = is_active;
 	world.skybox = skybox;
-	world.sprites = NULL;
+	world.sprites = malloc(sizeof(t_sprite **) * 9);
 	while (i < 9)
+	{
+		world.sprites[i] = NULL;
 		world_malloc(height * 3, width * 3, &world.world[i++]);
+	}
 	world_generator(&world);
+	sprites_generator(&world);
 	set_world(world, world_name);
 	return (true);
 }
Index: src/parsing/sprites_manager.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\n#include \"../../includes/includes.h\"\n\nt_sprite\t**realloc_sprites(t_sprite **sprites, int len)\n{\n\tt_sprite\t**new_tab;\n\tint\t\t\ts;\n\n\ts = -1;\n\tnew_tab = (t_sprite **)malloc(sizeof(t_sprite *) * (len + 2));\n\twhile (++s < len)\n\t\tnew_tab[s] = sprites[s];\n\tnew_tab[s] = (t_sprite *)malloc(sizeof(t_sprite));\n\tnew_tab[s + 1] = NULL;\n\tif (sprites)\n\t\tfree(sprites);\n\treturn (new_tab);\n}\n\nstatic void\tselect_options(t_sprite *sp, char c)\n{\n\tif (c == '>')\n\t{\n\t\tif (!set_texture_from_path(\"assets/sprites/pink_tulip.png\", &sp->texture))\n\t\t\tmsg_write(2, 2, ERROR_FATAL);\n\t\tsp->hostile = false;\n\t\tsp->scale = 228;\n\t}\n\telse if (c == '<')\n\t{\n\t\tif (!set_texture_from_path(\"assets/sprites/poppy.png\", &sp->texture))\n\t\t\tmsg_write(2, 2, ERROR_FATAL);\n\t\tsp->hostile = false;\n\t\tsp->scale = 228;\n\t}\n\telse if (c == 'v')\n\t{\n\t\tif (!set_texture_from_path(\"assets/sprites/brown_mushroom.png\", &sp->texture))\n\t\t\tmsg_write(2, 2, ERROR_FATAL);\n\t\tsp->hostile = false;\n\t\tsp->scale = 196;\n\t}\n\telse if (c == '^')\n\t{\n\t\tif (!set_texture_from_path(\"assets/sprites/carrots_stage1.png\", &sp->texture))\n\t\t\tmsg_write(2, 2, ERROR_FATAL);\n\t\tsp->hostile = false;\n\t\tsp->scale = 312 + get_rand_num(412, 2);\n\t}\n\telse if (c == '*')\n\t{\n\t\tif (!set_texture_from_path(\"assets/trash_do_not_remove/e_0.png\", &sp->texture))\n\t\t\tmsg_write(2, 2, ERROR_FATAL);\n\t\tsp->hostile = true;\n\t\tsp->scale = 576;\n\t}\n}\n\nvoid\tfree_all_sprites(t_sprite ***sprites)\n{\n\tint\ts;\n\n\ts = 0;\n\tif (!*sprites)\n\t\treturn ;\n\twhile (*sprites[s])\n\t{\n\t\tfree(*sprites[s]);\n\t\t*sprites[s] = NULL;\n\t}\n\tfree(*sprites[s]);\n\tfree(*sprites);\n}\n\nvoid\tdelete_sprite(t_sprite **sprites, int s)\n{\n\tint\tlen;\n\tint\ti;\n\n\tlen = 0;\n\twhile (sprites && sprites[s])\n\t\tlen++;\n\tif (!sprites || len < s)\n\t\treturn ;\n\tfree(sprites[s]);\n\ti = s;\n\twhile (i++ < len)\n\t\tsprites[s] = sprites[s + 1];\n\tsprites = realloc_sprites(sprites, len - 1);\n}\n\nt_sprite\t*get_sprite_by_int(t_sprite **sprites, int x, int y)\n{\n\tint\ts;\n\n\ts = 0;\n\tif (!sprites || !sprites[0])\n\t\treturn (NULL);\n\twhile (sprites[s])\n\t{\n\t\tif ((int)(sprites[s]->sp_xy[0] / 64) == x\n\t\t&& (int)(sprites[s]->sp_xy[1] / 64) == y)\n\t\t\treturn (sprites[s]);\n\t}\n\treturn (NULL);\n}\n\nvoid\tadd_sprite(t_world *world, char c, int y, int x)\n{\n\tint\tlen;\n\n\tlen = 0;\n\twhile (world->sprites != NULL && world->sprites[len])\n\t\tlen++;\n\tif (world->sprites == NULL)\n\t{\n\t\tworld->sprites = (t_sprite **)malloc(sizeof(t_sprite *) * 2);\n\t\tworld->sprites[0] = (t_sprite *)malloc(sizeof(t_sprite));\n\t\tworld->sprites[1] = NULL;\n\t}\n\telse\n\t\tworld->sprites = realloc_sprites(world->sprites, len);\n\tif (!world->sprites[len])\n\t\treturn ;\n\tworld->sprites[len]->c = c;\n\tworld->sprites[len]->cell_xy[0] = (int)(x + world->width);\n\tworld->sprites[len]->cell_xy[1] = (int)(y + world->height);\n\tworld->sprites[len]->sp_xy[0] = ((float)\n\t\t\t(world->sprites[len]->cell_xy[0]) + 0.5f) * 64;\n\tworld->sprites[len]->sp_xy[1] = ((float)\n\t\t\t(world->sprites[len]->cell_xy[1]) + 0.5f) * 64;\n\tworld->sprites[len]->chunk_sp_xy[0] = world->sprites[len]->sp_xy[0];\n\tworld->sprites[len]->chunk_sp_xy[1] = world->sprites[len]->sp_xy[1];\n\tselect_options(world->sprites[len], c);\n\tworld->world[4][y][x] = '0';\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/parsing/sprites_manager.c b/src/parsing/sprites_manager.c
--- a/src/parsing/sprites_manager.c	
+++ b/src/parsing/sprites_manager.c	
@@ -1,7 +1,7 @@
 
 #include "../../includes/includes.h"
 
-t_sprite	**realloc_sprites(t_sprite **sprites, int len)
+void realloc_sprites(t_sprite ***sprites, int len)
 {
 	t_sprite	**new_tab;
 	int			s;
@@ -9,12 +9,15 @@
 	s = -1;
 	new_tab = (t_sprite **)malloc(sizeof(t_sprite *) * (len + 2));
 	while (++s < len)
-		new_tab[s] = sprites[s];
+		new_tab[s] = (*sprites)[s];
 	new_tab[s] = (t_sprite *)malloc(sizeof(t_sprite));
 	new_tab[s + 1] = NULL;
-	if (sprites)
-		free(sprites);
-	return (new_tab);
+	if (*sprites)
+	{
+		free(*sprites);
+		*sprites = NULL;
+	}
+	*sprites = new_tab;
 }
 
 static void	select_options(t_sprite *sp, char c)
@@ -54,83 +57,221 @@
 		sp->hostile = true;
 		sp->scale = 576;
 	}
+	else if (c == ':')
+	{
+		if (!set_texture_from_path("assets/sprites/crimson_fungus.png", &sp->texture))
+			msg_write(2, 2, ERROR_FATAL);
+		sp->hostile = false;
+		sp->scale = 196;
+	}
+	else if (c == ';')
+	{
+		if (!set_texture_from_path("assets/sprites/fire_coral.png", &sp->texture))
+			msg_write(2, 2, ERROR_FATAL);
+		sp->hostile = false;
+		sp->scale = 312 + get_rand_num(412, 2);
+	}
+	else if (c == '?')
+	{
+		if (!set_texture_from_path("assets/sprites/warped_fungus.png", &sp->texture))
+			msg_write(2, 2, ERROR_FATAL);
+		sp->hostile = false;
+		sp->scale = 196;
+	}
+	else if (c == '/')
+	{
+		if (!set_texture_from_path("assets/sprites/wither_rose.png", &sp->texture))
+			msg_write(2, 2, ERROR_FATAL);
+		sp->hostile = false;
+		sp->scale = 196;
+	}
 }
 
-void	free_all_sprites(t_sprite ***sprites)
+void	free_all_sprites(t_world *world)
 {
 	int	s;
+	int	chunk;
 
-	s = 0;
-	if (!*sprites)
-		return ;
-	while (*sprites[s])
+	chunk = -1;
+	while (++chunk < 9)
 	{
-		free(*sprites[s]);
-		*sprites[s] = NULL;
+		s = -1;
+		if (!world->sprites[chunk])
+			continue ;
+		while (world->sprites[chunk][++s])
+			free(world->sprites[chunk][s]);
+		free(world->sprites[chunk]);
 	}
-	free(*sprites[s]);
-	free(*sprites);
 }
 
-void	delete_sprite(t_sprite **sprites, int s)
-{
-	int	len;
-	int	i;
+//void	delete_sprite(t_sprite **sprites, int s)
+//{
+//	int	len;
+//	int	i;
+//
+//	len = 0;
+//	while (sprites && sprites[s])
+//		len++;
+//	if (!sprites || len < s)
+//		return ;
+//	free(sprites[s]);
+//	i = s;
+//	while (i++ < len)
+//		sprites[s] = sprites[s + 1];
+//	sprites = realloc_sprites(sprites, len - 1);
+//}
 
-	len = 0;
-	while (sprites && sprites[s])
-		len++;
-	if (!sprites || len < s)
-		return ;
-	free(sprites[s]);
-	i = s;
-	while (i++ < len)
-		sprites[s] = sprites[s + 1];
-	sprites = realloc_sprites(sprites, len - 1);
-}
-
-t_sprite	*get_sprite_by_int(t_sprite **sprites, int x, int y)
+void	reload_sprite_pos(t_world *world)
 {
+	int	chunk;
 	int	s;
 
-	s = 0;
-	if (!sprites || !sprites[0])
-		return (NULL);
-	while (sprites[s])
+	chunk = -1;
+	while (++chunk < 9)
 	{
-		if ((int)(sprites[s]->sp_xy[0] / 64) == x
-		&& (int)(sprites[s]->sp_xy[1] / 64) == y)
-			return (sprites[s]);
+		s = -1;
+		while (world->sprites[chunk][++s])
+		{
+			world->sprites[chunk][s]->cell_xy[0] = (int)(world->sprites
+				[chunk][s]->x_origin + (world->width * (chunk % 3)));
+			world->sprites[chunk][s]->cell_xy[1] = (int)(world->sprites
+				[chunk][s]->y_origin + (world->height * (int)
+						lround(((float)chunk - 1.f) / 3.f)));
+			world->sprites[chunk][s]->sp_xy[0] = ((float)
+					(world->sprites[chunk][s]->cell_xy[0]) + 0.5f) * 64;
+			world->sprites[chunk][s]->sp_xy[1] = ((float)
+					(world->sprites[chunk][s]->cell_xy[1]) + 0.5f) * 64;
+			world->sprites[chunk][s]->chunk_sp_xy[0] = world->sprites
+			[chunk][s]->sp_xy[0];
+			world->sprites[chunk][s]->chunk_sp_xy[1] = world->sprites
+			[chunk][s]->sp_xy[1];
+		}
 	}
-	return (NULL);
 }
 
-void	add_sprite(t_world *world, char c, int y, int x)
+void	move_multiple_sprites_bis(t_world *world, int dir)
+{
+	t_sprite	**chunk1;
+	t_sprite	**chunk2;
+	t_sprite	**chunk3;
+
+	if (dir == 5)
+	{
+		chunk1 = world->sprites[0];
+		chunk2 = world->sprites[3];
+		chunk3 = world->sprites[6];
+		world->sprites[0] = world->sprites[1];
+		world->sprites[3] = world->sprites[4];
+		world->sprites[6] = world->sprites[7];
+		world->sprites[1] = world->sprites[2];
+		world->sprites[4] = world->sprites[5];
+		world->sprites[7] = world->sprites[8];
+		world->sprites[2] = chunk1;
+		world->sprites[5] = chunk2;
+		world->sprites[8] = chunk3;
+	}
+	else if (dir == 7)
+	{
+		chunk1 = world->sprites[0];
+		chunk2 = world->sprites[1];
+		chunk3 = world->sprites[2];
+		world->sprites[0] = world->sprites[3];
+		world->sprites[1] = world->sprites[4];
+		world->sprites[2] = world->sprites[5];
+		world->sprites[3] = world->sprites[6];
+		world->sprites[4] = world->sprites[7];
+		world->sprites[5] = world->sprites[8];
+		world->sprites[6] = chunk1;
+		world->sprites[7] = chunk2;
+		world->sprites[8] = chunk3;
+	}
+}
+
+void	move_multiple_sprites(t_world *world, int dir)
+{
+	t_sprite	**chunk1;
+	t_sprite	**chunk2;
+	t_sprite	**chunk3;
+
+	if (dir == 1)
+	{
+		chunk1 = world->sprites[6];
+		chunk2 = world->sprites[7];
+		chunk3 = world->sprites[8];
+		world->sprites[6] = world->sprites[3];
+		world->sprites[7] = world->sprites[4];
+		world->sprites[8] = world->sprites[5];
+		world->sprites[3] = world->sprites[0];
+		world->sprites[4] = world->sprites[1];
+		world->sprites[5] = world->sprites[2];
+		world->sprites[0] = chunk1;
+		world->sprites[1] = chunk2;
+		world->sprites[2] = chunk3;
+	}
+	else if (dir == 3)
+	{
+		chunk1 = world->sprites[2];
+		chunk2 = world->sprites[5];
+		chunk3 = world->sprites[8];
+		world->sprites[2] = world->sprites[1];
+		world->sprites[5] = world->sprites[4];
+		world->sprites[8] = world->sprites[7];
+		world->sprites[1] = world->sprites[0];
+		world->sprites[4] = world->sprites[3];
+		world->sprites[7] = world->sprites[6];
+		world->sprites[0] = chunk1;
+		world->sprites[3] = chunk2;
+		world->sprites[6] = chunk3;
+	}
+	else
+		move_multiple_sprites_bis(world, dir);
+}
+
+char	get_rand_sprite_char(t_world *world)
+{
+	static const char	tab_default[] = {'>', '<', '^', 'v'};
+	static const char	tab_nether[] = {':', ';', '?', '/'};
+
+	if (world->world_name == WORLD_DEFAULT)
+		return (tab_default[get_rand_num(4, 1)]);
+	else
+		return (tab_nether[get_rand_num(4, 1)]);
+}
+
+void	sprites_place(t_world *world, int chunk)
+{
+	move_multiple_sprites(world, chunk);
+	reload_sprite_pos(world);
+}
+
+void	add_sprite(t_world *world, int chunk, char c, int y, int x)
 {
 	int	len;
 
 	len = 0;
-	while (world->sprites != NULL && world->sprites[len])
+	while (world->sprites[chunk] != NULL && world->sprites[chunk][len])
 		len++;
-	if (world->sprites == NULL)
+	if (world->sprites[chunk] == NULL)
 	{
-		world->sprites = (t_sprite **)malloc(sizeof(t_sprite *) * 2);
-		world->sprites[0] = (t_sprite *)malloc(sizeof(t_sprite));
-		world->sprites[1] = NULL;
+		world->sprites[chunk] = (t_sprite **)malloc(sizeof(t_sprite *) * 2);
+		world->sprites[chunk][0] = (t_sprite *)malloc(sizeof(t_sprite));
+		world->sprites[chunk][1] = NULL;
 	}
 	else
-		world->sprites = realloc_sprites(world->sprites, len);
-	if (!world->sprites[len])
-		return ;
-	world->sprites[len]->c = c;
-	world->sprites[len]->cell_xy[0] = (int)(x + world->width);
-	world->sprites[len]->cell_xy[1] = (int)(y + world->height);
-	world->sprites[len]->sp_xy[0] = ((float)
-			(world->sprites[len]->cell_xy[0]) + 0.5f) * 64;
-	world->sprites[len]->sp_xy[1] = ((float)
-			(world->sprites[len]->cell_xy[1]) + 0.5f) * 64;
-	world->sprites[len]->chunk_sp_xy[0] = world->sprites[len]->sp_xy[0];
-	world->sprites[len]->chunk_sp_xy[1] = world->sprites[len]->sp_xy[1];
-	select_options(world->sprites[len], c);
-	world->world[4][y][x] = '0';
+		realloc_sprites(&world->sprites[chunk], len);
+	world->sprites[chunk][len]->c = c;
+	world->sprites[chunk][len]->x_origin = x;
+	world->sprites[chunk][len]->y_origin = y;
+	world->sprites[chunk][len]->cell_xy[0] = (int)(world->sprites
+		[chunk][len]->x_origin + (world->width * (chunk % 3)));
+	world->sprites[chunk][len]->cell_xy[1] = (int)(world->sprites
+		[chunk][len]->y_origin + (world->height
+				* lround(((float)chunk - 1.f) / 3.f)));
+	world->sprites[chunk][len]->sp_xy[0] = ((float)
+			(world->sprites[chunk][len]->cell_xy[0]) + ((get_rand_num(9, 1) / 10) + 0.2f)) * 64;
+	world->sprites[chunk][len]->sp_xy[1] = ((float)
+			(world->sprites[chunk][len]->cell_xy[1]) + ((get_rand_num(9, 1) / 10) + 0.2f)) * 64;
+	world->sprites[chunk][len]->chunk_sp_xy[0] = world->sprites[chunk][len]->sp_xy[0];
+	world->sprites[chunk][len]->chunk_sp_xy[1] = world->sprites[chunk][len]->sp_xy[1];
+	select_options(world->sprites[chunk][len], c);
 }
